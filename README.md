# Spring 핵심 원리 강의

<br>

## 요구사항

<br>

### 회원
- 등급은 일반과 VIP
- 회원 DB는 자체 구축할 수도 있고, 외부 시스템과 연동할 수도 있음 -> 인터페이스, 구현체로 설계

<br>

### 주문, 할인
- VIP 회원은 1000월 할인
- 할인 정책은 변경 가능성이 있음 -> 인터페이스, 구현체로 설계 

<br>

## 회원 도메인 설계
### 협력 관계
- 클라
- 회원 서비스
  - 회원가입
  - 회원조회
- 회원 저장소 - 미확정이기 때문에 데이터 접근 계층을 따로 만듦 (인터페이스)
  - 메모리 회원 저장서
  - DB 회원 저장소
  - 외부 시스템 회원 저장소

### 클래스 다이어그램
- 회원 서비스 (인터페이스)
- 회원 서비스 구현체
- 회원 저장소 (인터페이스)
  - 메모리 회원 저장소
  - DB 회원 저장소


<br>

## 주문, 할인 도메인 설계
### 주문, 할인 정책
- 회원 등급에 따라 할인 정책이 적용됨
- VIP는 고정 금액으로 1000원 할인이 적용됨
- 할인 정책은 서비스 오픈 직전에도 변경될 수 있음

- 주문 도메인 협력, 역할, 책임
  1. 주문 생성
  2. 회원 조회
  3. 할인 적용
  4. 주문 결과 반환

- 역할과 책임으로 나누는 이유: 추후에 책임을 담당하는 구형체가 바뀔 가능성에 대비해 역할/책임으로 나누고, 책임 객체만 바꿔 끼울 수 있게 하기 위함
- 역할들의 협력 관계는 그대로 유지가 됨

<br>

## Tips!
- HashMap 대신에 ConcurrnetHashMap을 쓰자
  - ConcurrentHashMap은 동시성을 지원하는 HashMap 클래스
  - HashMap는 내부적으로 동기화되지 않고 스레드로부터 안전하지 않음
  - ConcurrentHashMap은 내부적으로 동기화되어 스레드로부터 안전 (추가 및 삭제와 같은 수정 작업만)
- psvm
  - Public Static Void main(String[] arg);

<br>
    
## 관심사의 분리
- 애플리케이션은 추상간의 협력?
- 조영호님의 Object를 읽어보자
- 구현체가 아닌 추상을 의존하게 하는 것이 좋은 설계. 구현체는 구현만 담당하고, 추상을 의존하게 해야 코드 유지보수에 용이하다.
- 코드 간에도 클라이언트 코드, 서버 코드가 있다.
- AppConfig: 애플리케이션의 전체 동작 방식을 구성. 구현 객체를 생성하고 연결하는 책임을 가짐
  - 클라이언트 객체는 자신의 역할을 실행하는 데에만 집중

<br>

## 좋은 객체 지향 설계  5가지 원칙

- S(Solid): SRP 단일 책임 원칙. 한 클래스는 하나의 책임만 가진다.
- O(OCP): 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- L
- I
- D(DIP): 의존관계 역전 원칙. 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안 된다.

<br>

## IoC, DI, 컨테이너

### IoC
- 기존: 클라이언트 구현 객체가 필요한 객체를 직접 생성, 연결, 실행 -> 구현 객체가 프로그램 제어 흐름을 스스로 결정
- AppConfig 등장 후: 구현 객체를 로직만 담당, 객체 연결은 AppConfig에서 담당 -> 제어 흐름을 AppConfig가 가져감
=> 프로그램 제어 흐름을 직접 제어하는 것이 아닌 외부에서 제어하는 것이 제어의 역전

- 프레임워크: 내가 작성한 코드를 제어하고 대신 실행하면, 그것은 프레임워크
- 라이브러리: 내가 작성한 코드가 직접 제어권을 담당한다면, 그것은 라이브러리

<br>

### DI
- OrderServiceImpl은 DiscountPolicy 인터페이스에 의존하기 때문에 구체적인 할인 정책을 구현하는 구현 객체는 모름
- 의존 관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 인스턴스 의존관계를 분리해서 생각해야 함
- 정적: 소스코드 상에서 확인할 수 있는 의존관계
- 동적: 애플리케이션 실행 시점에서, 객체의 인스턴스의 참조가 연결된 의존관계
=> 의존관계 주입을 사용하면 정적 클래스 의존관계를 변경하지 않고, 동적 인스턴스 의존관계를 쉽개 변경할 수 있음

<br>

### IoC 컨테이너, DI 컨테이너
- AppConfig와 같이 객체를 생성 및 관리를 해주며 의존관계를 설정해주는 객체

<br>

### 스프링 컨테이너
- new AnnotationConfigApplicationContext(AppConfig.class);를 통해 만들어진 인스턴스를 스프링 컨테이너라 함
- AppConfig.class를 파라미터로 받아서 AppConfig 클래스에서 @Bean 어노테이션이 붙은 설정 정보를 스프링 빈 저장소에 등록
- 빈 이름은 중복되어서는 안 됨
- 빈이 등록이 되면, 의존관계를 설정해줌

<br>

### 컨테이너에 등록된 빈
- AppConfig도 빈으로 등록됨
- getRole() == ROLE_APPLICATION : 사용자가 정의한 빈
- getRole() == ROLE_INFRASTRUCTURE : 스프링 내부에서 사용하는 빈

<br>

### 동일한 타입의 빈이 둘 이상일 경우
- 타입으로만 빈을 조회했을 경우, 같은 타입의 빈이 둘 이상 등록되어 있으면 에러 발생
- 그럴 경우 빈 이름을 지정해서 조죄할 수 있음
- 둘 다 꺼내고 싶은 경우 getBeansOfType(); 메서드로 조회, Map 객체 리턴

<br>

### 스프링 빈 상속
- 스피링 빈을 조회할 때, 부모 타입을 조회하면 자식들도 다 끌려옴
- 모든 자바 객체의 최고 부모인 Object로 조회를 하면, 모든 스프링 빈이 조회됨

<br>

### BeanFactory와 ApplicationContext
BeanFactory (interface)<br>
ㄴ(상속) ApplicationContext (interface) : BeanFactory에 부가기능을 추가한 거라고 이해할 수 있음<br>
ㄴ(상속) AnnotationConfigApplicationContext : 구현객체


- BeanFactory
  - 스프링 컨테이너의 최상위 인터페이스
  - 스프링 빈을 관리하고 조회하는 기능을 갖고 있음
  - getBean() 메서드 등

- ApplicationContext
  - BeanFactory의 기능을 모두 상속받아서 제공
  - 부가 기능
    - MessageSource(메시지소스): 한국어 요청이면 한국어 데이터, 영어 요청이면 영어 데이터 출력
    - EnvironmentCapable(환경변수): 로컬, 개발, 운영 환경을 구분해서 처리
    - ApplicationEventPublisher(애플리케이션 이벤트): 이벤트를 발생하고 구독하는 모델을 편리하게 지원
    - ResourceLoader(편리한 리소스): 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

- BeanFactory나 ApplicationContext를 스프링 컨테이너라고 하고, 우리는 ApplicationContext만 사용한다고 해도 무방함

<br>

### 설정 정보
- 요즘은 대부분 자바 코드로 설정 사용
- xml을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있음. 하지만 레거시.
- 스프링에 빈 등록하는 두 가지 방법
  - 직접 등록 (xml 파일)
  - Factory 메서드를 사용하여 등록 (Java 코드) - 외부에서 메서드를 호출해서 생성하는 방식을 의미

<br>

## 싱글톤 컨테이너

### 웹 어플리케이션과 싱글톤
- 웹 어플리케이션 특성상 여러 고객이 동시에 요청을 함
- 많은 수의 사용자가 한 번씩 요청을 할 때마다 객체를 여러 개 만들 필요는 없음
- jvm 메모리에 계속 객체가 쌓이는 것은 불필요
- 객체가 바라보고 있는 다른 객체도 생성하기 때문에 비효율적임
- 싱글톤은 객체를 한 번 만드는 패턴으로, 한 번 생성된 객체를 공유하는 방식

<br>

### 싱글톤 패턴
- jvm 위에 클래스 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- private 생성자를 사용해서 외부에서 임의로 new 키워드로 인스턴스를 생성하지 못하도록 막음

- new 키워드를 사용하여 자기 자신을 내부에 private로 선언하여 instance를 생성
- static으로 선언 -> 클래스 레벨로 올라감
- 그러면 외부에서 new 키워드를 사용하여 인스턴스 생성 시도 시에 컴파일 에러 발생
- static으로 선언된 instance를 리턴하는 getInstance() 메서드를 생성
- 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있음. 항상 같은 instance를 리턴.

- 잘 설계한 객체는 컴파일 오류만으로 잡히는 객체

- assertThat(A).isSameAs(B); -> 참조값을 비교하는 것 (==)
- assertThat(A).isEqualTo(B); -> 값을 비교하는 것 (equals())

- 문제점
  - 구현 코드 자체가 많이 들어감
  - 클라이언트가 구체 코드에 의존함 -> DIP 위반
  - 내부 속성 변경 및 초기화가 어려움
  - 유연성이 떨어짐
  - 안티패턴으로 불리기도 함

- 스프링은 위 문제점을 모두 해결해주면서 객체를 싱글톤으로 관리해줌

<br>

### 싱글톤 컨테이너
- 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리함
- 지금까지 학습한 빈이 싱글톤 컨테이너로 관리되는 빈
- 지저분한 코드 사용하지 않아도 됨
- DIP, OCP, 테스트, private 생성자 등으로부터 자유롭게 사용할 수 있음

<br>

### 싱글톤 방식의 주의점
- 여러 클라이언트가 공유하는 객체이기 때문에, 상태를 유지하게 설계하면 안 되고, 무상태로 설계해야 함
- 특정 클라이언트에 의존적인 필드가 있으면 안 됨. 값 변경이 가능하게 하면 안 됨
- 읽기만 가능하게 설계해야 함
- 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 함

<br>

## 컴포넌트 스캔

### 컴포넌트 스캔과 의존관계 자동 주입
- 일일이 @Bean을 등록하기가 번거로울 때가 있음
- 컴포넌트 스캔: 설정 정보가 없어도 자동으로 빈을 등록해주는 기능
- @Autowired: 의존관계를 자동으로 주입해줌

- 설정 클래스에 @ComponentScan을 달기 -> @Component가 붙은 클래스를 찾아 자동으로 스프링 빈으로 등록해줌
- excludeFilters: 빈으로 등록하지 않을 것들을 빼주는 작업
- @Bean으로 등록한 클래스가 하나도 없음
- 참고) @Configuration 어노테이션을 열어보면 @Component가 붙어있음

- 기존 설정 클래스 파일에서는 빈 등록, 의존관계 설정을 모두 함
- 하지만, 컴포넌트 스캔을 사용하기 위해서는 설정 클래스에서 빈을 등록하는 것이 아니라, 대상이 되는 클래스에 @Component 어노테이션을 달아서 빈을 등록
- 그렇다면 의존관계 설정은 어떻게 하지? -> 생성자에 @Autowired를 달면 자동 의존관계 주입이 됨

- 그래서 Component 스캔을 쓰게 되면, @Autowired를 자연스럽게 사용하게 됨

- ComponenetScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록함
- 이 때, 빈 이름은 클래스명을 사용하고, 제일 앞 알파벳은 소문자로 바꿈
- 빈 이름 직접 지정 가능
- @Autowired로 의존성 주입 시, 스프링 빈에서 조회하여 주입. 타입으로 조회


<br>

## 다양한 의존관계 주입

### 생성자 주입
- 컴포넌트 스캔 시 빈을 등록할 때 생성자가 호출되는데, 그 때 의존관계가 주입되는 것
- 특징: 생성자 호출 시점에 딱 한 번만 호출됨
- 불변, 필수 의존관계에만 사용됨
- 생성자가 한 개만 있으면, @Autowired를 생략해도 됨
- 생성자 주입은 독특하게, 빈을 등록하면서 의존성 주입도 같이 일어남. 빈을 등록하려면 생성자를 호출해야 하기 때문

### 수정자 주입 (Setter 주입)
- setter 메서드에 @Autowired를 붙여 사용
- 선택적으로 설정할 수 있는 경우, 변경 가능한 의존관계에 사용
- 자바빈 프로퍼티 규약에 따라, 필드에 접근할 때는 get필드명(), set필드명()으로 접근
- ex) setName(); getName();

### 필드 주입
- 선언한 필드 제일 앞에 @Autowired를 붙임
- 외부에서 변경이 불가능해 테스트하기 어려움
- 필드 주입 후, 해당 필드를 외부에서 변경하기 위해서는 setter를 만들어야 함
- DI 프레임워크 없으면 아무것도 할 수 없음. 순수한 자바 코드로 테스트하기 불가능
- 사용하지 말자!

- 사용하도 되는 경우
  - 애플리케이션 코드와 관계 없는 테스트 코드에서는 사용하면 편함

### 일반 메서드 주입
- 아무 메서드에 @Autowired를 붙일 수 있음
- 일반적으로 잘 사용하지 않음
- 한 번에 여러 필드를 주입받을 수 있음

### 참고
- @Autowired는 주입할 대상이 없으면 오류를 발생시킴
- 스프링 빈이 아닌 클래스 안에서는 @Autowired를 적용해도 아무런 동작을 하지 않음

<br>

### 옵션 처리
- 주입할 스프링 빈이 없어도 동작해야 할 때가 있음
- @Autowired만 사용하면, 기본 설정 때문애 주입할 빈이 없을 시에 오류가 발생함
- @Autowired(required=false) -> 자동 주입할 대상이 없으면, 수정자 메서드 자체가 호출이 안 됨
- org.springframework.lang.@Nullable -> 자동 주입할 대상이 없으면, null이 등록됨
- Optional<> -> 자동 주입할 대상이 없으면, Optional.empty가 등록됨

<br>

### 생성자 주입을 선택하자
- 왜?
- 불변
  - 대부분의 의존관계는 애플리케이션 종료 전까지 변하지 않음
  - 애플리케이션이 돌아가는 중에 의존관계를 변경할 수 있는 여지를 주는 것은 좋은 설계가 아님
- 누락
  - 순수한 자바 코드로 테스트할 경우가 많은데, 예를 들어, 수정자 주입으로 의존관계 설정 시, 의존하려는 필드에 대한 nullPointerException이 터짐
  - 임시 객체라도 할당을 해야 하는데, 그렇게 되면 테스트하는 데에 굉장히 어려움.
  - 생성자 주입을 사용하면, 테스트 코드 상에서 의존하려는 필드를 직접 주입할 수 있음.

- final 키워드를 사용할 수 있음
  - 의존관계를 설정할 때 값이 할당되어서 바뀌지 않음.
  - 생성자에서만 값을 넣어줄 수 있음.
  - 혹시 생성자에서 값을 누락했더라도 final 키워드가 에러를 알려줌.

- 컴파일 오류가 세상에서 가장 좋은 오류!

<br>

### Lombok
- 라이브러리 인젝션을 추가해줌
- 필수! Lombok 설치 후 preference에서 compiler > annotation processors에서 enable annotation processing을 켜줘야 함
- @Getter(), @Setter(), @ToString
- Getter는 많이 쓰임, Setter는 조심히
- @RequiredArgumentConstructor() - 많이 사용됨
- final이 붙은 필드를 파라미터로 받는 생성자를 만들어줌
- 최근에는 생성자를 한 개 두고, @Autowired를 생략하는 방법을 많이 씀. 여기에 Lombok의 @NoArgumentConstructor를 함께 써서 기능은 다 사용하면서 코드늨 간결하게 쓸 수 있음


### 여러개의 빈이 선택될 때
- @Autowired에 필드명을 매칭
  - 타입으로 매칭
  - 타입 매칭의 결과가 2개 이상일 경우, 필드명 또는 파라미터 명으로 빈 이름 매칭

- @Qualifier를 사용
  - 추가 구분자
  - @Qualifier는 @Qualifier를 찾는 데에만 쓰는 것에 안 헷갈림
 
- @Primary - 자주 사용됨
  - @Autowired 매칭 시에 여러번 매칭 되면 @Primary가 우선권을 가짐

- @Qualifier가 @Primary보다 우선순위가 높음
  



